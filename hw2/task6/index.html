<!DOCTYPE html>
<html lang="en"  class="theme--light" >

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/images/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/images/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/images/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/images/apple-touch-icon-57x57.png" />
  <link rel="short icon" href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/images/favicon.png" type="image/x-icon" />
  <link rel="stylesheet" href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/style.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" rel="stylesheet">
  <title> • Loop Subdivision for Mesh Upsampling</title>
  
  
  
</head>

<body>
  <div id="sidebar" class="animated fadeInDown">
    <div class="logo-title">
      <div class="title">
        <img src=https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/images/mirror_cloth.png style="width:80%;" alt="logo" />
        <h3><a href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/"></a></h3>
        <div class="description">
          <p></p>
        </div>
      </div>
    </div>
    <ul class="social-links">
      
    </ul>
    <div class="footer">
      
      <span>Designed by </span><a href="https://www.caicai.me">CaiCai</a>
      <div class="by_zola"><a href="https://www.getzola.org/" target="_blank">Proudly published with Zola!</a></div>
      
    </div>
  </div>
  <div id="main">
    <div class="page-top animated fadeInDown">
      <div class="nav">
        
        
        
        
        <li><a  href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/">Home</a></li>
        <li><a  href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/hw1/">Homework 1</a></li>
        <li><a class="current"  href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/hw2/">Homework 2</a></li>
        <li><a  href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/hw3/">Homework 3</a></li>
        <li><a  href="https://cal-cs184-student.github.io/hw-webpages-sp24-lethalNeutrino/hw4/">Homework 4</a></li>
      </div>
      <div class="information">
        <div class="back_btn">
          <a onclick="window.history.go(-1)" ><i
              class="fas fa-chevron-left"></i></a>
        </div>
        
        
        
      </div>
    </div>
    <div class="autopagerize_page_element">
      <div class="content">
        
<article class="post animated fadeInDown">
  <h1><a href="https:&#x2F;&#x2F;cal-cs184-student.github.io&#x2F;hw-webpages-sp24-lethalNeutrino&#x2F;hw2&#x2F;task6&#x2F;">Loop Subdivision for Mesh Upsampling</a></h1>
  
  <div class="post-content"><h2 id="what-is-loop-subdivision">What is loop subdivision?</h2>
<p>Sometimes, we may want to increase the number of polygons in our mesh to smooth out jagged edges and create a more smoothly curved surface, specifically by adding more polygons to areas where faces meet at sharp angles. This is called <em>mesh upsampling.</em> One approach to rounding out these edges is <em>loop subdivision</em> for triangle meshes, which consists of dividing each triangle into 4 by connecting the midpoints of each side, then updating the positions of vertices as follows:</p>
<ul>
<li>
<p>For a vertex that existed in the old mesh, we interpolate between the original position of that vertex and the average of all of its neighboring vertices <em>in the original mesh</em>. To be precise, we weight the original position of the vertex by $1-nu$, where $n$ is the <em>degree</em> (number of neighboring vertices) of the vertex and $u$ is $\frac{3}{16}$ if $n = 3$, otherwise $\frac{3}{8n}$. Then we weight the sum of the positions of the neighbor vertices by $u$.</p>
</li>
<li>
<p>For a vertex that was added in the creation of the new mesh (essentially a vertex that used to be the midpoint of an edge), we assign its position based on the four vertices involved in splitting the edge (in the original mesh) the vertex is the midpoint. We add $\frac{3}{8}$ times the positions of the two endpoints of the edge, and $\frac{1}{8}$ times the positions of the two other vertices that form the two triangles with the relevant edge.</p>
</li>
</ul>
<p>Here is a diagram to show what these updated positions look like geometrically:</p>
<p style = "text-align:center">
	<img src="../task6-vertex-positions.png" alt="Diagram of computation of vertex positions" width="60%" style="text-align:center"/>
</p>
*Credit to CS 184 staff for this diagram*
<p>This overall has the effect of pushing new vertices slightly outwards, while pulling old vertices in, which smooths out harsh edges and introduces some new curvature.</p>
<h2 id="how-do-we-implement-it">How do we implement it?</h2>
<p>Our implementation was essentially split into 5 steps:</p>
<ol>
<li>First, iterate over all vertices currently in the mesh (the &quot;old&quot; vertices) and compute what its new position will be in the upscaled mesh. Store this value in the <code>newPosition</code> field of the vertex.</li>
<li>Then, iterate over all edges currently in the mesh and compute what the position of the vertex that will be created by splitting this edge should be. Store this value in the <code>newPosition</code> field of the edge.</li>
<li>Split every <em>old</em> edge in the mesh (don't create new edges then split them too, or we'll be stuck in an infinite loop). While we're doing this, we also update any new edges we create (edges that are actually created by the edge split operation, not just the result of a pre-existing edge being split in two) to keep track of their new status in the <code>isNew</code> field.</li>
<li>Flip any <em>new</em> edge (determined in step 3) that connects a new vertex and an old vertex. After this step is complete, we have subdivided every triangle in the manner described in the previous section.</li>
<li>Update every vertex to its new position as calculated in steps 1 and 2.</li>
</ol>
<h3 id="wait-this-works">Wait, this works?</h3>
<p>It may seem surprising that steps 3 and 4 actually do divide every triangle in the 4-1 fashion that we described conceptually above.
However, we can just consider an arbitrary triangle in the mesh; we split its three edges in some arbitrary order.</p>
<p style = "text-align:center">
	<img src="../task6-subdivision-proof.png" alt="Diagram of equivalence between subdivision generation methods" width="30%" style="text-align:center"/>
</p>
<p>In this diagram, we split the red outer edge first giving us the red edge through the triangle, then we split the blue and green outer edges in any order giving us the other blue and green edges.
The first edge we split will create a new edge that connects an old vertex (the one between the green and blue edges) and a new vertex (the one in the middle of the red edge).
Then, the other two edges will connect exactly as they're supposed to in order to subdivide the triangle into 4 triangles.
Now, all we have to do is flip the red inner edge and we'll split the triangle as desired; the red inner edge will now connect the pure blue vertex and pure green vertex, which is exactly what we wanted to happen, and we've divided the mesh like we were supposed to.</p>
<h3 id="debugging-woes">Debugging woes</h3>
<p>We initially had a bug where some vertices' positions were getting set to 0; this was because we didn't realize that a new vertex's halfedge may not point to the edge that stored the vertex's new position, which means it was just getting set to 0 instead because the relevant edges hadn't had their &quot;<code>newPosition</code>&quot; field set. 
So, when we found a new vertex (denoted by the <code>isNew</code> flag) and tried to check the relevant edge for its <code>newPosition</code> field by checking the vertex's halfedge's edge, we sometimes found a blank <code>newPosition</code> field and set the vertex's position to 0, which was not great.
Once we realized this, we implemented a nice trick that got around this problem entirely.
In particular, we set the vertex's <code>newPosition</code> field during the edge split operation (where we have immediate access to both the vertex and the edge that we're splitting). At the end, we don't have to search for the correct edge anymore; we just set all vertices' positions to their <code>newPosition</code> field.</p>
<h2 id="notes-and-observations-on-smoothness">Notes and observations on smoothness</h2>
<p>In general, objects will turn smoother after being upsampled with loop-subdivision. Below are three sets of upsampled meshes:</p>
<p style="text-align:center">
<img src="../teapot0.png" style="width:20%"> <img src="../teapot-no-mesh0.png" style="width:20%">
<img src="../teapot2.png" style="width:20%"> <img src="../teapot-no-mesh2.png" style="width:20%"><br>
<img src="../cow0.png" style="width:20%"> <img src="../cow-no-mesh0.png" style="width:20%">
<img src="../cow3.png" style="width:20%"> <img src="../cow-no-mesh3.png" style="width:20%"><br>
<img src="../torus0.png" style="width:20%"> <img src="../torus-no-mesh0.png" style="width:20%">
<img src="../torus3.png" style="width:20%"> <img src="../torus-no-mesh3.png" style="width:20%"><br>
Above: the teapot, cow, and torus mesh after being subdivided several times. The teapot was subdivided twice, and the torus and cow were subdivided 3 times. Of note is the large amount of movement in the originally sharp edges of the torus.
</p>
<p>We see that sharp edges especially are pushed inwards by quite a large distance, due to them being far from their neighbors, and thus their neighbors have a stronger relative effect on their location. As shown in the next section, preprocessing these corners and edges by splitting their neighboring edges reduces the distance from other vertices for the vertices that experience the largest relative movement, which reduces this shrinking effect.</p>
<h2 id="why-does-my-symmetric-cube-turn-asymmetric">Why does my symmetric cube turn asymmetric?</h2>
<p>When upsampling the cube as is, we notice a bit of asymmetry, displayed below: </p>
<p style="text-align:center">
<img src="../cube1.png" style="width:40%">
<img src="../cube2.png" style="width:40%">
<img src="../cube3.png" style="width:40%">
<img src="../cube4.png" style="width:40%">
<img src="../cube5.png" style="width:40%">
<br>
Above: the original cube mesh displayed at 4 level of subdivision. The last image, which is a picture of the cube at a different rotation shows the asymmetry.
</p>
<p>This naturally arises due to the nature of the calculation of the new vertex positions as a weighted average of their positions and their neighbors positions. We can imagine the updated position of a vertex as each neighbor vertex &quot;tugging&quot; on the position of the vertex, shrinking it in towards the origin a little bit (for a convex piece of the surface). Since this formula preserves either $\frac{7}{16}$ of the original position for a vertex with degree 3 or $\frac{5}{8}$ of the position when the degree is greater than 3, asymmetries arise when there is a mix of vertices with degree 3 and greater in the original mesh. Intuitively, a vertex with degree only 3 is &quot;pulled harder&quot; by its neighbors, creating the asymmetry. Additionally, since the neighbors of a vertex with degree 4 or 5 are inherently not centered around the axis containing the vertex and its opposing corner of the cube, the vertex's new position will be skewed slightly off axis. Moreover, the edge division algorithm further accentuates this asymmetry, since the two connecting neighbors are weighted more than the two non-connecting neighbors, we end up accentuating the asymmetry when splitting the edges. In this example, we clearly see the cube being skewed where the original vertices of degree 3 have been pulled in further than the original vertices of degree 4 or greater, resulting in an asymmetry.</p>
<p>To fix this, we can take two approaches: the first is to simply split all the face-crossing edges of the original mesh. By doing this, visually we see that the mesh has the symmetries of a cube — all corner vertices have degree 6, and all face are identical. Thus, each corner vertex is pulled symmetrically towards the center as they all have the same degree, and they are not pulled off-axis, as the 6 points are equally distributed along the corner-to-corner axis of the cube. This implementation is demonstrated on the left below. Another way to do this is to flip the edges, leading to two opposing corners having degree 6 each, and the others all having degree 4. This will result in a cube with 1 3-fold axis of corner-to-corner rotational symmetry, demonstrated on the right below. However, this does not solve the off-axis distribution of the points for the vertices of degree 4, resulting in a shape with no reflectional symmetry. Depending on the desired goals, this may or may not be what is intended with a cube.</p>
<p style="text-align:center">
<img src="../cubesplit1.png" style="width:30%">  <img src="../cubeflip1.png" style="width:30%"> <br>
<img src="../cubesplit2.png" style="width:30%">  <img src="../cubeflip2.png" style="width:30%"> <br>
<img src="../cubesplit3.png" style="width:30%">  <img src="../cubeflip3.png" style="width:30%"> <br>
<img src="../cubesplit4.png" style="width:30%">  <img src="../cubeflip4.png" style="width:30%"> <br>
<img src="../cubesplit5.png" style="width:30%">  <img src="../cubeflip5.png" style="width:30%"> <br>
<br>
Left: The cube mesh preprocessed with face-edge splitting displayed at 4 levels of subdivision. The bottom image shows it from a different angle to show that it has retained the symmetries of a cube. Right: The cube mesh preprocessed with face-edge flipping displayed at 4 levels of subdivision. The bottom image shows it from a different angle to show that it retains an axis of rotational symmetry but has no mirror symmetries.
</p>
<p>Notice how in the example where the cube was split rather than flipped, the corners experience a relatively smaller movement inwards, as they are now closer to their neighbors. Had the mesh been further subdivided symmetrically, the shrinking effect would have been further reduced, as shown below:</p>
<p style="text-align:center">
<img src="../cubesplitsplit0.png" style="width:20%"> 
<img src="../cubesplitsplit1.png" style="width:20%"> 
<img src="../cubesplitsplit2.png" style="width:20%"> 
<img src="../cubesplitsplit3.png" style="width:20%"> 
<br>
<img src="../cubesplitsplitsplit0.png" style="width:20%"> 
<img src="../cubesplitsplitsplit1.png" style="width:20%"> 
<img src="../cubesplitsplitsplit2.png" style="width:20%"> 
<img src="../cubesplitsplitsplit3.png" style="width:20%"> 
<br>
<img src="../cubesplitsplitsplitsplit0.png" style="width:20%"> 
<img src="../cubesplitsplitsplitsplit1.png" style="width:20%"> 
<img src="../cubesplitsplitsplitsplit2.png" style="width:20%"> 
<img src="../cubesplitsplitsplitsplit3.png" style="width:20%"> 
</p>
<p>Overall, the lesson to take away is that even if the original mesh defines a shape, it's possible that the result after levels of subdivision is asymmetric, if the vertices are not all symmetric with respect to each other. The edges leading into vertices will each &quot;tug&quot; on that vertex, and the end result will be heavily influenced by any vertex asymmetries.</p>
</div>
  <div class="post-footer">
    <div class="meta">
      <div class="info">
        
        <i class="far fa-sun"></i><span class="date">2020-01-02</span>
        
        
      </div>
    </div>
  </div>
</article>
<div class="share">
  <div class="weibo">
    <a class="fab fa-weibo"
      href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&title=',e(d.title),'&appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a>
  </div>
  <div class="twitter">
    <a class="fab fa-twitter"
      href="http://twitter.com/share?text=Loop Subdivision for Mesh Upsampling&url=https:&#x2F;&#x2F;cal-cs184-student.github.io&#x2F;hw-webpages-sp24-lethalNeutrino&#x2F;hw2&#x2F;task6&#x2F;"></a>
  </div>
</div>







<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['$$', '$$'], ["\\[", "\\]"]],
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>




      </div>
    </div>
  </div>
  
  <script>
    function showLanguages() {
      let currentDisplay = document.getElementById("languages").style.display;
      if (currentDisplay == 'none') {
        document.getElementById("languages").style.display = 'block';
      } else {
        document.getElementById("languages").style.display = 'none';
      }
    }
  </script>
</body>

</html>
